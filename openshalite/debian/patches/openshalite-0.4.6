--- a/src/org/opensha/commons/data/function/ArbitrarilyDiscretizedFunc.java
+++ b/src/org/opensha/commons/data/function/ArbitrarilyDiscretizedFunc.java
@@ -64,7 +64,7 @@
     protected final static String C = "ArbitrarilyDiscretizedFunc";
 
     /* Boolean debugging variable to switch on and off debug printouts */
-    protected final static boolean D = true;
+    protected final static boolean D = false;
 
     /**
      * The set of DataPoints2D that conprise the discretized function. These are
--- a/src/org/opensha/sha/calc/disaggregation/DisaggregationCalculator.java
+++ /dev/null
@@ -1,1144 +0,0 @@
-/*******************************************************************************
- * Copyright 2009 OpenSHA.org in partnership with the Southern California
- * Earthquake Center (SCEC, http://www.scec.org) at the University of Southern
- * California and the UnitedStates Geological Survey (USGS; http://www.usgs.gov)
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not
- * use this file except in compliance with the License. You may obtain a copy of
- * the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- ******************************************************************************/
-
-package org.opensha.sha.calc.disaggregation;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.net.URL;
-import java.net.URLConnection;
-import java.rmi.RemoteException;
-import java.rmi.server.UnicastRemoteObject;
-import java.text.DecimalFormat;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Map;
-
-import org.apache.commons.lang.NotImplementedException;
-import org.opensha.commons.data.Site;
-import org.opensha.commons.data.function.ArbitrarilyDiscretizedFunc;
-// import org.opensha.commons.mapping.gmt.GMT_MapGenerator;
-import org.opensha.commons.param.ParameterAPI;
-import org.opensha.commons.param.WarningParameterAPI;
-// import org.opensha.commons.util.ServerPrefUtils;
-import org.opensha.sha.earthquake.EqkRupForecast;
-import org.opensha.sha.earthquake.ProbEqkRupture;
-import org.opensha.sha.earthquake.ProbEqkSource;
-import org.opensha.sha.imr.AttenuationRelationship;
-import org.opensha.sha.imr.PropagationEffect;
-import org.opensha.sha.imr.ScalarIntensityMeasureRelationshipAPI;
-import org.opensha.sha.imr.param.PropagationEffectParams.DistanceRupParameter;
-import org.opensha.sha.util.TRTUtils;
-import org.opensha.sha.util.TectonicRegionType;
-
-/**
- * <p>
- * Title: DisaggregationCalculator
- * </p>
- * <p>
- * Description: This class disaggregates a hazard curve based on the input
- * parameters imr, site and eqkRupforecast. See Bazzurro and Cornell (1999,
- * Bull. Seism. Soc. Am., 89, pp. 501-520) for a complete discussion of
- * disaggregation. The Dbar computed here is for rupture distance. This assumes
- * all sources in the ERF are Poissonian.
- * </p>
- * <p>
- * Copyright: Copyright (c) 2002
- * </p>
- * <p>
- * Company:
- * </p>
- * 
- * @author Ned Field
- * @date Oct 28, 2002
- * @version 1.0
- */
-
-public class DisaggregationCalculator extends UnicastRemoteObject implements
-        DisaggregationCalculatorAPI {
-
-    /**
-	 * 
-	 */
-    private static final long serialVersionUID = 1L;
-
-    protected final static String C = "DisaggregationCalculator";
-    protected final static boolean D = false;
-
-    // public static final String OPENSHA_SERVLET_URL =
-    // ServerPrefUtils.SERVER_PREFS.getServletBaseURL() +
-    // "DisaggregationPlotServlet";
-
-    // disaggregation stuff
-
-    private double[] mag_center, mag_binEdges;
-    private double[] dist_center, dist_binEdges;
-
-    private int NUM_E = 8;
-    private double[][][] pdf3D;
-    private double maxContrEpsilonForDisaggrPlot;
-    private double maxContrEpsilonForGMT_Plot;
-
-    private int iMag, iDist, iEpsilon;
-    private double mag, dist, epsilon;
-    private boolean withinBounds;
-
-    private double Mbar, Dbar, Ebar;
-    private int M_index_mode3D, D_index_mode3D; // E_mode3D;
-
-    // gets the Epsilon Range
-    private String epsilonRangeString;
-
-    private double totalRate, outOfBoundsRate;
-
-    private int currRuptures = -1;
-    private int totRuptures = 0;
-
-    // gets the number of sources to be shown in the disaggregation window
-    private int numSourcesToShow = 0;
-
-    private boolean showDistances = true;
-
-    // stores the source Disagg info
-    private String sourceDisaggInfo;
-
-    // Disaggregation Plot Img Name
-    public static final String DISAGGREGATION_PLOT_NAME = "DisaggregationPlot";
-    public static final String DISAGGREGATION_PLOT_IMG_NAME =
-            DISAGGREGATION_PLOT_NAME + ".jpg";
-    public static final String DISAGGREGATION_PLOT_PDF_NAME =
-            DISAGGREGATION_PLOT_NAME + ".pdf";
-
-    // Address to the disaggregation plot img
-    private String disaggregationPlotImgWebAddr;
-
-    static String[] epsilonColors = { "-G215/38/3", "-G252/94/62",
-            "-G252/180/158", "-G254/220/210", "-G217/217/255", "-G151/151/255",
-            "-G0/0/255", "-G0/0/170" };
-
-    /**
-     * creates the DisaggregationCalculator object
-     * 
-     * @throws java.rmi.RemoteException
-     * @throws IOException
-     */
-    public DisaggregationCalculator() throws java.rmi.RemoteException {
-
-        // set defaults
-        setMagRange(5, 9, 0.5);
-        setDistanceRange(5, 11, 10);
-
-        // Create adjustable parameters
-    }
-
-    /**
-     * this function performs the disaggregation. Returns true if it was
-     * succesfully able to disaggregate above a given IML else return false
-     * 
-     * @param iml
-     *            : the intensity measure level to disaggregate
-     * @param site
-     *            : site parameter
-     * @param imr
-     *            : selected IMR object
-     * @param eqkRupForecast
-     *            : selected Earthquake rup forecast
-     * @return boolean
-     */
-    public boolean disaggregate(double iml, Site site,
-            ScalarIntensityMeasureRelationshipAPI imr,
-            EqkRupForecast eqkRupForecast, double maxDist,
-            ArbitrarilyDiscretizedFunc magDistFilter)
-            throws java.rmi.RemoteException {
-        return disaggregate(iml, site, TRTUtils.wrapInHashMap(imr),
-                eqkRupForecast, maxDist, magDistFilter);
-    }
-
-    @Override
-    public
-            boolean
-            disaggregate(
-                    double iml,
-                    Site site,
-                    Map<TectonicRegionType, ScalarIntensityMeasureRelationshipAPI> imrMap,
-                    EqkRupForecast eqkRupForecast, double maxDist,
-                    ArbitrarilyDiscretizedFunc magDistFilter)
-                    throws RemoteException {
-
-        double rate, condProb;
-
-        DecimalFormat f1 = new DecimalFormat("000000");
-        DecimalFormat f2 = new DecimalFormat("00.00");
-
-        pdf3D = new double[dist_center.length][mag_center.length][NUM_E];
-
-        DistanceRupParameter distRup = new DistanceRupParameter();
-
-        String S = C + ": disaggregate(): ";
-
-        if (D)
-            System.out.println(S + "STARTING DISAGGREGATION");
-
-        if (D)
-            System.out.println(S + "iml = " + iml);
-
-        // if( D )System.out.println(S + "deltaMag = " + deltaMag +
-        // "; deltaDist = " + deltaDist + "; deltaE = " + deltaE);
-        ArrayList<DisaggregationSourceRuptureInfo> disaggSourceList = null;
-        DisaggregationSourceRuptureComparator srcRupComparator = null;
-        if (this.numSourcesToShow > 0) {
-            disaggSourceList = new ArrayList<DisaggregationSourceRuptureInfo>();
-            srcRupComparator = new DisaggregationSourceRuptureComparator();
-        }
-        // resetting the Parameter change Listeners on the
-        // AttenuationRelationship
-        // parameters. This allows the Server version of our application to
-        // listen to the
-        // parameter changes.
-        for (ScalarIntensityMeasureRelationshipAPI imr : imrMap.values())
-            ((AttenuationRelationship) imr).resetParameterEventListeners();
-
-        boolean includeMagDistFilter;
-        if (magDistFilter == null)
-            includeMagDistFilter = false;
-        else
-            includeMagDistFilter = true;
-        double magThresh = 0.0;
-
-        // set the maximum distance in the attenuation relationship
-        // (Note- other types of IMRs may not have this method so we should
-        // really check type here)
-        for (ScalarIntensityMeasureRelationshipAPI imr : imrMap.values())
-            imr.setUserMaxDistance(maxDist);
-
-        // set iml in imr
-        ParameterAPI<Double> im =
-                TRTUtils.getFirstIMR(imrMap).getIntensityMeasure();
-        if (im instanceof WarningParameterAPI<?>) {
-            WarningParameterAPI<Double> warnIM =
-                    (WarningParameterAPI<Double>) im;
-            warnIM.setValueIgnoreWarning(new Double(iml));
-        } else {
-            im.setValue(new Double(iml));
-        }
-
-        // get total number of sources
-        int numSources = eqkRupForecast.getNumSources();
-
-        // HashMap<String, ArrayList<?>> sourceDissaggMap = new HashMap<String,
-        // ArrayList<?>>();
-
-        // compute the total number of ruptures for updating the progress bar
-        totRuptures = 0;
-        for (int i = 0; i < numSources; ++i)
-            totRuptures += eqkRupForecast.getSource(i).getNumRuptures();
-
-        // init the current rupture number (also for progress bar)
-        currRuptures = 0;
-
-        for (ScalarIntensityMeasureRelationshipAPI imr : imrMap.values()) {
-            try {
-                // set the site in IMR
-                imr.setSite(site);
-            } catch (Exception ex) {
-                if (D)
-                    System.out.println(C + ":Param warning caught" + ex);
-                ex.printStackTrace();
-            }
-        }
-
-        // initialize
-        Ebar = 0;
-        Mbar = 0;
-        Dbar = 0;
-        totalRate = 0;
-        outOfBoundsRate = 0;
-
-        // initialize the PDF
-        for (int i = 0; i < dist_center.length; i++)
-            for (int j = 0; j < mag_center.length; j++)
-                for (int k = 0; k < NUM_E; k++)
-                    pdf3D[i][j][k] = 0;
-
-        int numRupRejected = 0;
-
-        for (int i = 0; i < numSources; i++) {
-
-            double sourceRate = 0;
-            // get source and get its distance from the site
-            ProbEqkSource source = eqkRupForecast.getSource(i);
-
-            String sourceName = source.getName();
-            int numRuptures = eqkRupForecast.getNumRuptures(i);
-
-            // check the distance of the source
-            double distance = source.getMinDistance(site);
-            if (distance > maxDist) {
-                currRuptures += numRuptures;
-                continue;
-            }
-
-            // get magThreshold if we're to use the mag-dist cutoff filter
-            if (includeMagDistFilter) {
-                magThresh = magDistFilter.getInterpolatedY(distance);
-            }
-
-            // set the IMR according to the tectonic region of the source (if
-            // there is more than one)
-            TectonicRegionType trt = source.getTectonicRegionType();
-            ScalarIntensityMeasureRelationshipAPI imr =
-                    TRTUtils.getIMRForTRT(imrMap, trt);
-
-            // if (numSourcesToShow > 0)
-            // sourceDissaggMap.put(sourceName, new ArrayList());
-
-            // loop over ruptures
-            for (int n = 0; n < numRuptures; n++, ++currRuptures) {
-
-                // get the rupture
-                ProbEqkRupture rupture = source.getRupture(n);
-
-                double qkProb = rupture.getProbability();
-
-                // apply magThreshold if we're to use the mag-dist cutoff filter
-                if (includeMagDistFilter && rupture.getMag() < magThresh) {
-                    numRupRejected += 1;
-                    continue;
-                }
-
-                // set the rupture in the imr
-                imr.setEqkRupture(rupture);
-
-                // get the cond prob
-                condProb = imr.getExceedProbability();
-                // should the following throw an exception?
-                if (condProb == 0 && D)
-                    System.out
-                            .println(S
-                                    + "Exceedance probability is zero! (thus the NaNs below)");
-
-                // get the mean, stdDev, epsilon, dist, and mag
-                epsilon = imr.getEpsilon();
-                distRup.setValue(rupture, site);
-                dist = ((Double) distRup.getValue()).doubleValue();
-                mag = rupture.getMag();
-
-                // get the equiv. Poisson rate over the time interval (not
-                // annualized)
-                rate = -condProb * Math.log(1 - qkProb);
-
-                /*
-                 * if( Double.isNaN(epsilon) && testNum < 1) {
-                 * System.out.println("srcName = " + sourceName + " src#=" + i +
-                 * " rup#=" + n + " qkProb=" + (float)qkProb + " condProb=" +
-                 * (float)condProb + " mean=" + (float)mean + " stdDev=" +
-                 * (float)stdDev + " epsilon=" + (float)epsilon + " dist=" +
-                 * (float)dist + " rate=" + (float)rate);
-                 * System.out.println(rupture
-                 * .getMag()+"  "+rupture.getRuptureSurface
-                 * ().get(0,0).toString());
-                 * System.out.println(rupture.getRuptureSurface
-                 * ().getNumCols()+"  "
-                 * +rupture.getRuptureSurface().getNumRows());
-                 * System.out.println(site.getLocation().toString()); Iterator
-                 * it = site.getParametersIterator(); while(it.hasNext())
-                 * System.out.println(
-                 * ((Parameter)it.next()).getMetadataString() );
-                 * PropagationEffect pe = new PropagationEffect();
-                 * pe.setAll(rupture,site);
-                 * System.out.println(pe.getParamValue(DistanceSeisParameter
-                 * .NAME));
-                 * 
-                 * testNum += 1; }
-                 */
-
-                // proceed only if rate is greater than zero (avoids NaN
-                // epsilons & is faster)
-                if (rate > 0.0) {
-                    // set the 3D array indices & check that all are in bounds
-                    setIndices();
-                    if (withinBounds)
-                        pdf3D[iDist][iMag][iEpsilon] += rate;
-                    else {
-                        if (D)
-                            System.out
-                                    .println("disaggregation(): Some bin is out of range");
-                        outOfBoundsRate += rate;
-                    }
-
-                    // if( D ) System.out.println("disaggregation(): bins: " +
-                    // iMag + "; " + iDist + "; " + iEpsilon);
-
-                    totalRate += rate;
-
-                    Mbar += rate * mag;
-                    Dbar += rate * dist;
-                    Ebar += rate * epsilon;
-                    sourceRate += rate;
-
-                }
-                // create and add rupture info to source list
-                /*
-                 * if (numSourcesToShow > 0) { double eventRate = -Math.log(1 -
-                 * qkProb); // this event rate is not annualized!
-                 * DisaggregationSourceRuptureInfo rupInfo = new
-                 * DisaggregationSourceRuptureInfo(null, eventRate, (float)
-                 * rate, n, mag,dist); ( (ArrayList)
-                 * sourceDissaggMap.get(sourceName)).add(rupInfo); }
-                 */
-
-            }
-            if (numSourcesToShow > 0) {
-                // sort the ruptures in this source according to contribution
-                // ArrayList sourceRupList = (ArrayList)
-                // sourceDissaggMap.get(sourceName);
-                // Collections.sort(sourceRupList,srcRupComparator);
-                // create the total rate info for this source
-                DisaggregationSourceRuptureInfo disaggInfo =
-                        new DisaggregationSourceRuptureInfo(sourceName,
-                                (float) sourceRate, i, source);
-                disaggSourceList.add(disaggInfo);
-            }
-        }
-
-        // if no rate of exceedance above a given IML then return false.
-        if (!(totalRate > 0))
-            return false;
-
-        // sort the disaggSourceList according to contribution
-        if (numSourcesToShow > 0) {
-            Collections.sort(disaggSourceList, srcRupComparator);
-            // make a string of the sorted list info
-            sourceDisaggInfo =
-                    "Source#\t% Contribution\tTotExceedRate\tSourceName";
-            if (showDistances)
-                sourceDisaggInfo += "\tDistRup\tDistX\tDistSeis\tDistJB";
-            sourceDisaggInfo += "\n";
-            int size = disaggSourceList.size();
-            if (size > numSourcesToShow)
-                size = numSourcesToShow;
-            // overide to only give the top 100 sources (otherwise can be to big
-            // and cause crash)
-            for (int i = 0; i < size; ++i) {
-                DisaggregationSourceRuptureInfo disaggInfo =
-                        (DisaggregationSourceRuptureInfo) disaggSourceList
-                                .get(i);
-                sourceDisaggInfo +=
-                        f1.format(disaggInfo.getId())
-                                + "\t"
-                                + f2.format(100 * disaggInfo.getRate()
-                                        / totalRate) + "\t"
-                                + (float) disaggInfo.getRate() + "\t"
-                                + disaggInfo.getName();
-
-                if (showDistances) {
-                    ProbEqkSource source = disaggInfo.getSource();
-                    double mag = 0;
-                    for (int rupID = 0; rupID < source.getNumRuptures(); rupID++) {
-                        double myMag = source.getRupture(rupID).getMag();
-                        if (myMag > mag)
-                            mag = myMag;
-                    }
-
-                    ProbEqkRupture fakeRupture =
-                            new ProbEqkRupture(mag, 0, 0,
-                                    source.getSourceSurface(), null);
-                    PropagationEffect pEffect =
-                            new PropagationEffect(site, fakeRupture);
-                    sourceDisaggInfo +=
-                            "\t" + f2.format(pEffect.getDistanceRup()) + "\t"
-                                    + f2.format(pEffect.getDistanceX()) + "\t"
-                                    + f2.format(pEffect.getDistanceSeis())
-                                    + "\t" + f2.format(pEffect.getDistanceJB());
-                }
-
-                sourceDisaggInfo += "\n";
-                // System.out.println(f2.format(100*disaggInfo.getRate()/totalRate));
-            }
-        }
-        /*
-         * try { FileWriter fw = new FileWriter("Source_Rupture_OpenSHA.txt");
-         * String sourceRupDisaggregationInfo =
-         * "#Source-Id  Source-Rate   Rupture-Id   Mag   Distance   Rupture-Exceed-Rate Rupture-Rate  Source-Name\n"
-         * ; fw.write(sourceRupDisaggregationInfo); int size =
-         * disaggSourceList.size(); for (int i = 0; i < size; ++i) {
-         * DisaggregationSourceRuptureInfo disaggInfo = (
-         * DisaggregationSourceRuptureInfo) disaggSourceList.get(i); String
-         * sourceName = disaggInfo.getName(); String sourceInfo =
-         * disaggInfo.getId() + "\t" + (float) disaggInfo.getRate(); ArrayList
-         * rupList = (ArrayList) sourceDissaggMap.get(sourceName); int
-         * rupListSize = rupList.size(); for (int j = 0; j < rupListSize; ++j) {
-         * DisaggregationSourceRuptureInfo disaggRupInfo =
-         * (DisaggregationSourceRuptureInfo) rupList.get(j);
-         * sourceRupDisaggregationInfo = sourceInfo + "\t" +
-         * disaggRupInfo.getId() + "\t" + disaggRupInfo.getMag() + "\t" +
-         * disaggRupInfo.getDistance() + "\t"+ (float) disaggRupInfo.getRate() +
-         * "\t" + (float) disaggRupInfo.getEventRate() + "\t" + sourceName +
-         * "\n"; fw.write(sourceRupDisaggregationInfo); } }
-         * 
-         * fw.close(); } catch (IOException ex1) { ex1.printStackTrace(); }
-         */
-
-        Mbar /= totalRate;
-        Dbar /= totalRate;
-        Ebar /= totalRate;
-        if (D)
-            System.out.println(S + "Mbar = " + Mbar);
-        if (D)
-            System.out.println(S + "Dbar = " + Dbar);
-        if (D)
-            System.out.println(S + "Ebar = " + Ebar);
-
-        maxContrEpsilonForDisaggrPlot = -1;
-        int modeMagBin = -1, modeDistBin = -1, modeEpsilonBin = -1;
-        double maxContrBinRate = -1;
-        for (int i = 0; i < dist_center.length; i++) {
-            for (int j = 0; j < mag_center.length; j++) {
-                double contrEpsilonSum = 0;
-                for (int k = 0; k < NUM_E; k++) {
-                    pdf3D[i][j][k] = pdf3D[i][j][k] / totalRate * 100; // convert
-                                                                       // to
-                    // summing over all the contributing Epsilon for a given
-                    // dist and Mag.
-                    contrEpsilonSum += pdf3D[i][j][k];
-                    if (pdf3D[i][j][k] > maxContrBinRate) {
-                        maxContrBinRate = pdf3D[i][j][k];
-                        modeDistBin = i;
-                        modeMagBin = j;
-                        modeEpsilonBin = k;
-                    }
-                }
-                if (contrEpsilonSum > maxContrEpsilonForDisaggrPlot)
-                    maxContrEpsilonForDisaggrPlot = contrEpsilonSum;
-            }
-        }
-        M_index_mode3D = modeMagBin;
-        D_index_mode3D = modeDistBin;
-        epsilonRangeString = this.getEpsilonRange(modeEpsilonBin);
-        // E_mode3D = eps(modeEpsilonBin);
-
-        if (D)
-            System.out.println(S + "MagModeIndex = " + M_index_mode3D
-                    + "; binNum = " + modeMagBin);
-        if (D)
-            System.out.println(S + "DistModeIndex = " + D_index_mode3D
-                    + "; binNum = " + modeDistBin);
-        if (D)
-            System.out.println(S + "EpsMode = " + epsilonRangeString
-                    + "; binNum = " + modeEpsilonBin);
-        // if( D ) System.out.println(S + "EpsMode = " + E_mode3D +
-        // "; binNum = " + modeEpsilonBin);
-
-        System.out.println("numRupRejected=" + numRupRejected);
-
-        return true;
-    }
-
-    /**
-     * 
-     * Returns the disaggregated source list with following info ( in each line)
-     * 1)Source Id as given by OpenSHA 2)Name of the Source 3)Rate Contributed
-     * by that source 4)Percentage Contribution of the source in Hazard at the
-     * site.
-     * 
-     * @return String
-     * @throws RemoteException
-     */
-    public String getDisaggregationSourceInfo() throws java.rmi.RemoteException {
-        if (numSourcesToShow > 0)
-            return sourceDisaggInfo;
-        return "";
-    }
-
-    /**
-     * Setting up the Mag Range
-     * 
-     * @param minMag
-     *            double - this is the center of the first bin
-     * @param numMags
-     *            int
-     * @param deltaMag
-     *            double
-     */
-    public void setMagRange(double minMag, int numMags, double deltaMag)
-            throws java.rmi.RemoteException {
-        mag_center = new double[numMags];
-        mag_binEdges = new double[numMags + 1];
-        mag_binEdges[0] = minMag - deltaMag / 2;
-        for (int i = 0; i < numMags; i++) {
-            mag_center[i] = minMag + i * deltaMag;
-            mag_binEdges[i + 1] = mag_center[i] + deltaMag / 2;
-        }
-    }
-
-    /**
-     * Setting up the Mag Range
-     * 
-     * @param dmagBinEdges
-     *            - a double array of the distance-bin edges (in correct order,
-     *            from low to high)
-     */
-    public void setMagRange(double[] magBinEdges)
-            throws java.rmi.RemoteException {
-        this.mag_binEdges = magBinEdges;
-        mag_center = new double[mag_binEdges.length - 1];
-        for (int i = 0; i < mag_center.length; i++)
-            mag_center[i] = (mag_binEdges[i] + mag_binEdges[i + 1]) / 2;
-    }
-
-    /**
-     * Setting up the Distance Range
-     * 
-     * @param minDist
-     *            double - this is the center of the first bin
-     * @param numDist
-     *            int
-     * @param deltaDist
-     *            double
-     */
-    public void setDistanceRange(double minDist, int numDist, double deltaDist)
-            throws java.rmi.RemoteException {
-        dist_center = new double[numDist];
-        dist_binEdges = new double[numDist + 1];
-        dist_binEdges[0] = minDist - deltaDist / 2;
-        for (int i = 0; i < numDist; i++) {
-            dist_center[i] = minDist + i * deltaDist;
-            dist_binEdges[i + 1] = dist_center[i] + deltaDist / 2;
-        }
-        // hack test:
-        // double[] temp = {0,1,2,5,10,20,50,100,200};
-        // setDistanceRange(temp);
-    }
-
-    /**
-     * Setting up the Distance Range
-     * 
-     * @param distBinEdges
-     *            - a double array of the distance-bin edges (in correct order,
-     *            from low to high)
-     */
-    public void setDistanceRange(double[] distBinEdges)
-            throws java.rmi.RemoteException {
-        this.dist_binEdges = distBinEdges;
-        dist_center = new double[distBinEdges.length - 1];
-        for (int i = 0; i < dist_center.length; i++)
-            dist_center[i] = (distBinEdges[i] + distBinEdges[i + 1]) / 2;
-    }
-
-    /**
-     * Sets the Max Z Axis Range value for plotting purposes
-     * 
-     * @param zMax
-     * @throws java.rmi.RemoteException
-     */
-    public void setMaxZAxisForPlot(double zMax) throws java.rmi.RemoteException {
-        if (!Double.isNaN(zMax))
-            maxContrEpsilonForGMT_Plot = zMax;
-        else
-            maxContrEpsilonForGMT_Plot = this.maxContrEpsilonForDisaggrPlot;
-    }
-
-    /**
-     * gets the number of current rupture being processed
-     * 
-     * @return
-     */
-    public int getCurrRuptures() throws java.rmi.RemoteException {
-        return this.currRuptures;
-    }
-
-    /**
-     * gets the total number of ruptures
-     * 
-     * @return
-     */
-    public int getTotRuptures() throws java.rmi.RemoteException {
-        return this.totRuptures;
-    }
-
-    /**
-     * Checks to see if disaggregation calculation for the selected site have
-     * been completed.
-     * 
-     * @return
-     */
-    public boolean done() throws java.rmi.RemoteException {
-        return (currRuptures == totRuptures);
-    }
-
-    /**
-     * 
-     * @returns resultant disaggregation in a String format.
-     * @throws java.rmi.RemoteException
-     */
-    public String getMeanAndModeInfo() throws java.rmi.RemoteException {
-
-        float mm_l = (float) mag_binEdges[M_index_mode3D];
-        float mm_u = (float) mag_binEdges[M_index_mode3D + 1];
-        float dm_l = (float) dist_binEdges[D_index_mode3D];
-        float dm_u = (float) dist_binEdges[D_index_mode3D + 1];
-        // float em_l = (float) (E_mode3D-deltaE/2.0);
-        // float em_u = (float) (E_mode3D+deltaE/2.0);
-        String results;
-
-        results =
-                "\n" + "\n  Mbar = " + (float) Mbar + "\n  Dbar = "
-                        + (float) Dbar + "\n  Ebar = " + (float) Ebar + "\n"
-                        + "\n  " + mm_l + " � Mmode < " + mm_u + "\n  "
-                        + dm_l + " � Dmode < " + dm_u;
-        /*
-         * if( E_mode3D == Double.NEGATIVE_INFINITY || E_mode3D ==
-         * Double.POSITIVE_INFINITY) results += "\n  Emode = " + E_mode3D; else
-         * results += "\n  " + em_l+" � Emode < " + em_u;
-         */
-        results += "\n" + epsilonRangeString;
-
-        if (totalRate == 0.0)
-            results +=
-                    "\n\nNote:\n"
-                            + "The above NaN values result from the chosen IML\n"
-                            + "(or that interpolated from the chosen probability)\n"
-                            + "never being exceeded.";
-
-        /*
-         * results = "Disaggregation Result:\n\n\tMbar = " + Mbar +
-         * "\n\tDbar = " + Dbar + "\n\tEbar = " + Ebar + "\n\n\tMmode = " +
-         * M_mode3D + "\n\tDmode = " + D_mode3D + "\n\tEmode = " + E_mode3D;
-         */
-
-        return results;
-
-    }
-
-    /**
-     * Returns the Bin Data in the String format
-     * 
-     * @return String
-     * @throws RemoteException
-     */
-    public String getBinData() throws java.rmi.RemoteException {
-
-        DecimalFormat f1 = new DecimalFormat("0.00");
-        DecimalFormat f2 = new DecimalFormat("00.00");
-        DecimalFormat f3 = new DecimalFormat("000.00");
-        double totPercent, percent;
-
-        String binInfo =
-                "Dist\tMag\tE�-2\t-2<E�-1\t-1<E�-0.5\t "
-                        + "-0.5>E�0\t 0<E�0.5\t 0.5<E�1\t 1<E�2\t 2>E \n";
-        binInfo +=
-                "-----\t----\t------\t------\t-------\t"
-                        + "-------\t-------\t-------\t-------\t------\n";
-        for (int i = 0; i < dist_center.length; ++i) {
-            for (int j = 0; j < mag_center.length; ++j) {
-                binInfo +=
-                        f3.format(dist_center[i]) + " \t "
-                                + f1.format(mag_center[j]) + " \t ";
-                String E_String = "";
-                totPercent = 0;
-                for (int k = 0; k < NUM_E; ++k) {
-                    percent = pdf3D[i][j][k];
-                    E_String += f2.format(percent) + " \t ";
-                    totPercent += percent;
-                }
-                binInfo += E_String + f2.format(totPercent) + "\n";
-            }
-        }
-        return binInfo;
-    }
-
-    private void setIndices() {
-        withinBounds = true;
-        iMag = -1;
-        iDist = -1;
-
-        // Get mag bin
-        for (int i = 0; i < mag_center.length; i++)
-            if (mag >= mag_binEdges[i] && mag < mag_binEdges[i + 1]) {
-                iMag = i;
-                break;
-            }
-
-        // Get the dist bin
-        for (int i = 0; i < dist_center.length; i++)
-            if (dist >= dist_binEdges[i] && dist < dist_binEdges[i + 1]) {
-                iDist = i;
-                break;
-            }
-
-        if (epsilon <= -2)
-            iEpsilon = 0;
-        else if (epsilon > -2 && epsilon <= -1)
-            iEpsilon = 1;
-        else if (epsilon > -1 && epsilon <= -0.5)
-            iEpsilon = 2;
-        else if (epsilon > -0.5 && epsilon <= 0)
-            iEpsilon = 3;
-        else if (epsilon > 0 && epsilon <= 0.5)
-            iEpsilon = 4;
-        else if (epsilon > 0.5 && epsilon <= 1.0)
-            iEpsilon = 5;
-        else if (epsilon > 1.0 && epsilon <= 2.0)
-            iEpsilon = 6;
-        else if (epsilon > 2.0)
-            iEpsilon = 7;
-
-        if (iMag == -1)
-            withinBounds = false;
-        if (iDist == -1)
-            withinBounds = false;
-
-    }
-
-    /**
-     * Gets the Epsilon range String based on the index of the epsilon
-     * 
-     * @param iEpsilon
-     *            int
-     * @return String
-     */
-    private String getEpsilonRange(int iEpsilon) {
-
-        switch (iEpsilon) {
-        case 0:
-            return "Emode <= -2";
-        case 1:
-            return "-2 < Emode <= -1";
-        case 2:
-            return "-1 < Emode <= -0.5";
-        case 3:
-            return "-0.5 < Emode <= 0.0";
-        case 4:
-            return "0.0 < Emode <= 0.5";
-        case 5:
-            return "0.5 < Emode <= 1.0";
-        case 6:
-            return "1.0 < Emode <= 2.0";
-        case 7:
-            return "2.0 < Emode ";
-        default:
-            return "Incorrect Index";
-        }
-    }
-
-    // /**
-    // * Gets the plot image for the Disaggregation
-    // * @param metadata String
-    // * @return String
-    // */
-    // public String getDisaggregationPlotUsingServlet(String metadata) throws
-    // java.
-    // rmi.RemoteException {
-    // DisaggregationPlotData data = new DisaggregationPlotData(mag_center,
-    // mag_binEdges, dist_center, dist_binEdges,
-    // maxContrEpsilonForGMT_Plot, NUM_E, pdf3D);
-    // disaggregationPlotImgWebAddr = openServletConnection(data, metadata);
-    // return disaggregationPlotImgWebAddr;
-    // }
-
-    /**
-     * Creates the GMT_Script lines
-     */
-    // public static ArrayList<String>
-    // createGMTScriptForDisaggregationPlot(DisaggregationPlotData data, String
-    // dir){
-    //
-    // double x_axis_length = 4.5; // in inches
-    // double y_axis_length = 4.0; // in inches
-    // double z_axis_length = 2.5; // in inches
-    //
-    // int numTicksToDrawForZAxis = 5;
-    // // compute z-axis tick spacing & max z value
-    // double z_tick =
-    // Math.ceil(data.getMaxContrEpsilonForGMT_Plot()/numTicksToDrawForZAxis);
-    // double maxZVal = z_tick * numTicksToDrawForZAxis;
-    // ArrayList<String> gmtScriptLines = new ArrayList<String>();
-    // //
-    // System.out.println(maxContrEpsilonForDisaggrPlot+"\t"+z_grid+"\t"+maxZVal);
-    //
-    // double dist_binEdges[] = data.getDist_binEdges();
-    // double mag_binEdges[] = data.getMag_binEdges();
-    // double dist_center[] = data.getDist_center();
-    // double mag_center[] = data.getMag_center();
-    //
-    // int numE = data.getNUM_E();
-    //
-    // double pdf3D[][][] = data.getPdf3D();
-    //
-    // // data.get
-    //
-    // float min_dist = (float) dist_binEdges[0];
-    // float max_dist = (float) dist_binEdges[dist_binEdges.length-1];
-    // float min_mag = (float) mag_binEdges[0];
-    // float max_mag = (float) mag_binEdges[mag_binEdges.length-1];
-    //
-    // double totDist = dist_binEdges[dist_binEdges.length-1]-dist_binEdges[0];
-    // double x_tick;
-    // if(totDist<115) x_tick = 10;
-    // else if (totDist<225) x_tick = 20;
-    // else if (totDist<335) x_tick = 30;
-    // else if (totDist<445) x_tick = 40;
-    // else x_tick = 50;
-    //
-    // double distBinWidthToInches = x_axis_length/totDist;
-    //
-    //
-    // double totMag = mag_binEdges[mag_binEdges.length-1]-mag_binEdges[0];
-    // double y_tick;
-    // if(totMag<5) y_tick = 0.5;
-    // else y_tick = 1.0;
-    //
-    // double magBinWidthToInches = y_axis_length/totMag;
-    //
-    // gmtScriptLines.add("#!/bin/bash");
-    // gmtScriptLines.add("");
-    // gmtScriptLines.add("cd " + dir);
-    // gmtScriptLines.add("");
-    // gmtScriptLines.addAll(GMT_MapGenerator.getGMTPathEnvLines());
-    // gmtScriptLines.add("## Plot Script ##");
-    // gmtScriptLines.add("");
-    //
-    // try{
-    // String region =
-    // "-R"+min_dist+"/"+max_dist+"/"+min_mag+"/"+max_mag+"/"+0+"/"+maxZVal;
-    // String projection = "-JX"+x_axis_length+"i/"+y_axis_length+"i";
-    // String viewAngle = "-E150/30";
-    // String boxPenWidth = "-W0.5p"; // pen width for drawing boxes
-    // String verticalScaling = "-JZ"+z_axis_length+"i";
-    // // temporarily switching background color to 0/0/0 from 180/180/180
-    // because anything
-    // // that's not pure white comes out as pure black
-    // gmtScriptLines.add("${GMT_PATH}gmtset PAGE_COLOR 255/255/255");
-    // gmtScriptLines.add("${GMT_PATH}gmtset X_ORIGIN 1.0i");
-    // gmtScriptLines.add("${GMT_PATH}gmtset Y_ORIGIN 2.0i");
-    // gmtScriptLines.add("");
-    // String img_ps_file = "DisaggregationPlot.ps";
-    //
-    // String axisBoundaryTicksBounds =
-    // "-B"+x_tick+":\"Rupture Distance (km)\":"+"/"+y_tick+":Magnitude:"+
-    // "/"+z_tick+":%Contribution:"+"wSnEZ";
-    // gmtScriptLines.add("${COMMAND_PATH}echo \"plotting axis\"");
-    // gmtScriptLines.add("${COMMAND_PATH}cat << END > temp_segments");
-    // //creating the grid lines on Z axis.
-    // //System.out.println(z_tick+"   "+maxZVal+"   "+maxContrEpsilonForDisaggrPlot);
-    // for (double k = z_tick; k <= maxZVal; k += z_tick) {
-    // gmtScriptLines.add(">");
-    // gmtScriptLines.add(min_dist+"  "+ min_mag+" "+k);
-    // gmtScriptLines.add(min_dist+"  "+max_mag+"  "+k);
-    // gmtScriptLines.add(">");
-    // gmtScriptLines.add(min_dist+"  "+ max_mag+"  "+k);
-    // gmtScriptLines.add(+max_dist+"   "+max_mag+"  "+k);
-    // }
-    // gmtScriptLines.add(">");
-    // gmtScriptLines.add(min_dist +"   "+ max_mag+"  " + 0);
-    // gmtScriptLines.add( min_dist + "  "+max_mag + "  " + maxZVal);
-    // gmtScriptLines.add(">");
-    // gmtScriptLines.add(max_dist + "  "+ max_mag + " " + 0);
-    // gmtScriptLines.add( + max_dist + "  " +max_mag+ " "+ maxZVal);
-    // gmtScriptLines.add("END");
-    // gmtScriptLines.add("");
-    //
-    // //creating the GMT_Script for the plot
-    // gmtScriptLines.add("${GMT_PATH}psxyz temp_segments -P "+
-    // region+" -M  " +projection +"  "+verticalScaling+" -K -G0/0/0 "+
-    // viewAngle + "  "+boxPenWidth+"  "+axisBoundaryTicksBounds
-    // +" >  "+img_ps_file);
-    //
-    // float contribution, base, top;
-    // gmtScriptLines.add("${COMMAND_PATH}echo \"plotting disagg\"");
-    // for (int i = 0; i < dist_center.length; ++i) {
-    // gmtScriptLines.add("${COMMAND_PATH}echo \"plotting dist bin " + i +
-    // "\"");
-    // for (int j = mag_center.length - 1; j >= 0; --j) { // ordering here is
-    // important
-    //
-    // double box_x_width = (dist_binEdges[i+1]-
-    // dist_binEdges[i])*distBinWidthToInches - 0.05; // lst term leaves some
-    // space
-    // double box_y_width = (mag_binEdges[j+1]-
-    // mag_binEdges[j])*magBinWidthToInches - 0.05;
-    // String symbol = " -So"+box_x_width+"i/"+box_y_width+"ib";
-    //
-    // base = 0;
-    // top = 0;
-    // for (int k = 0; k < numE; ++k) {
-    // contribution = (float) pdf3D[i][j][k];
-    // top = base + contribution;
-    // if (contribution > 0.0) {
-    // gmtScriptLines.add("${COMMAND_PATH}echo " + "\"" + dist_center[i] + " " +
-    // mag_center[j] + " " + top +
-    // "\"" +
-    // " | ${GMT_PATH}psxyz "
-    // + "-P " + region + " " + projection + " " +
-    // verticalScaling + symbol + base +
-    // " -K -O " + epsilonColors[k] + "  " +
-    // viewAngle +
-    // "  " + boxPenWidth + " >> " + img_ps_file);
-    // base = top;
-    // }
-    //
-    // }
-    // }
-    // }
-    //
-    // gmtScriptLines.add("");
-    // gmtScriptLines.add("${COMMAND_PATH}echo \"plotting legend\"");
-    // // add the legend boxes
-    // // 1st legend box has origin offset in Y by -2 inches (and X by minus
-    // some too)
-    // gmtScriptLines.add("${COMMAND_PATH}echo " + "\"" +
-    // dist_binEdges[dist_binEdges.length-1] + " " + mag_binEdges[0] + " " +
-    // (0.8*z_tick) +
-    // "\"" + " | ${GMT_PATH}psxyz " + "-P -Y-1.25i -X-4.2i " +
-    // region + " " +
-    // projection + " " + verticalScaling + " -So0.3ib0 " +
-    // " -K -O " +
-    // epsilonColors[0] + "  " + viewAngle + "  " + boxPenWidth +
-    // " >> " + img_ps_file);
-    //
-    // // each now has origin offset in the X direction
-    // for (int k = 1; k < numE; ++k) {
-    // gmtScriptLines.add("${COMMAND_PATH}echo " + "\"" +
-    // dist_binEdges[dist_binEdges.length-1] + " " + mag_binEdges[0] + " " +
-    // (0.8*z_tick) +
-    // "\"" + " | ${GMT_PATH}psxyz " + "-P -X0.9i " +
-    // region + " " +
-    // projection + " " + verticalScaling + " -So0.3ib0 " +
-    // " -K -O " +
-    // epsilonColors[k] + "  " + viewAngle + "  " + boxPenWidth +
-    // " >> " + img_ps_file);
-    // }
-    //
-    //
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"0.0 0.75 13 0.0 12 CB e<-2\" > temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"0.9 0.75 13 0.0 12 CB -2<e<-1\" >> temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"1.8 0.75 13 0.0 12 CB -1<e<-0.5\" >> temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"2.7 0.75 13 0.0 12 CB -0.5<e<0\" >> temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"3.6 0.75 13 0.0 12 CB 0<e<0.5\" >> temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"4.5 0.75 13 0.0 12 CB 0.5<e<1\" >> temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"5.4 0.75 13 0.0 12 CB 1<e<2\" >> temp_label");
-    // gmtScriptLines.add("${COMMAND_PATH}echo " +
-    // "\"6.3 0.75 13 0.0 12 CB 2<e\" >> temp_label");
-    // // on gravity we used -X-2.45, but for some reason that puts stuff to the
-    // right
-    // // on opensha.usc.edu
-    // gmtScriptLines.add("${GMT_PATH}pstext temp_label -R0/8.5/0/11 -N -Jx1i -X-6.1 -P -O >> "
-    // + img_ps_file);
-    // gmtScriptLines.add("");
-    // gmtScriptLines.add("${COMMAND_PATH}echo \"converting postscript\"");
-    // gmtScriptLines.add("${COMMAND_PATH}cat "+img_ps_file+ " |"+
-    // "gs -sDEVICE=jpeg -sOutputFile=temp.jpg"+" -");
-    // gmtScriptLines.add("${PS2PDF_PATH} "+img_ps_file+"  "+DISAGGREGATION_PLOT_PDF_NAME);
-    // gmtScriptLines.add("${CONVERT_PATH} -crop 0x0 temp.jpg "+DISAGGREGATION_PLOT_IMG_NAME);
-    // gmtScriptLines.add("${COMMAND_PATH}rm temp.jpg temp_segments");
-    // }catch(Exception e){
-    // e.printStackTrace();
-    // }
-    //
-    // return gmtScriptLines;
-    // }
-
-    /**
-     * sets up the connection with the servlet on the server (gravity.usc.edu)
-     */
-    // private String openServletConnection(DisaggregationPlotData data,
-    // String metadata) throws RuntimeException{
-    //
-    // String webaddr=null;
-    // try{
-    //
-    // if(D) System.out.println("starting to make connection with servlet");
-    // URL gmtPlotServlet = new URL(OPENSHA_SERVLET_URL);
-    //
-    //
-    // URLConnection servletConnection = gmtPlotServlet.openConnection();
-    // if(D) System.out.println("connection established");
-    //
-    // // inform the connection that we will send output and accept input
-    // servletConnection.setDoInput(true);
-    // servletConnection.setDoOutput(true);
-    //
-    // // Don't use a cached version of URL connection.
-    // servletConnection.setUseCaches (false);
-    // servletConnection.setDefaultUseCaches (false);
-    // // Specify the content type that we will send binary data
-    // servletConnection.setRequestProperty
-    // ("Content-Type","application/octet-stream");
-    //
-    // ObjectOutputStream outputToServlet = new
-    // ObjectOutputStream(servletConnection.getOutputStream());
-    //
-    //
-    // //sending the disagg data
-    // outputToServlet.writeObject(data);
-    // //sending the contents of the Metadata file to the server.
-    // outputToServlet.writeObject(metadata);
-    //
-    //
-    // outputToServlet.flush();
-    // outputToServlet.close();
-    //
-    // // Receive the "actual webaddress of all the gmt related files"
-    // // from the servlet after it has received all the data
-    // ObjectInputStream inputToServlet = new
-    // ObjectInputStream(servletConnection.getInputStream());
-    //
-    // Object messageFromServlet = inputToServlet.readObject();
-    // inputToServlet.close();
-    // if(messageFromServlet instanceof String){
-    // webaddr = (String) messageFromServlet;
-    // if (D) System.out.println("Receiving the Input from the Servlet:" +
-    // webaddr);
-    // }
-    // else
-    // throw (RuntimeException)messageFromServlet;
-    // }catch(RuntimeException e){
-    // e.printStackTrace();
-    // throw new RuntimeException(e.getMessage());
-    // }catch (Exception e) {
-    // e.printStackTrace();
-    // throw new RuntimeException("Server is down , please try again later");
-    // }
-    // return webaddr;
-    // }
-
-    /**
-     * Sets the number of sources to be shown in the Disaggregation.
-     * 
-     * @param numSources
-     *            int
-     * @throws RemoteException
-     */
-    public void setNumSourcestoShow(int numSources) throws RemoteException {
-        numSourcesToShow = numSources;
-    }
-
-    public void setShowDistances(boolean showDistances)
-            throws java.rmi.RemoteException {
-        this.showDistances = showDistances;
-    }
-
-}
--- a/src/org/opensha/sha/calc/HazardCurveCalculatorAPI.java
+++ b/src/org/opensha/sha/calc/HazardCurveCalculatorAPI.java
@@ -190,12 +190,6 @@
             Site site, ScalarIntensityMeasureRelationshipAPI imr,
             EqkRupture rupture) throws java.rmi.RemoteException;
 
-    // gets the current rupture that is being processed
-    public int getCurrRuptures() throws java.rmi.RemoteException;
-
-    // gets the total number of ruptures.
-    public int getTotRuptures() throws java.rmi.RemoteException;
-
     /**
      * stops the Hazard Curve calculations.
      * 
@@ -249,15 +243,12 @@
      *            : selected IMR object
      * @param eqkRupForecast
      *            : selected Earthquake rup forecast
-     * @param updateCurrRuptures
-     *            : tells whether to update current ruptures (for the
-     *            getCurrRuptures() method used for progress bars)
      * @return
      */
     public DiscretizedFuncAPI getEventSetHazardCurve(
             DiscretizedFuncAPI hazFunction, Site site,
             ScalarIntensityMeasureRelationshipAPI imr,
-            ArrayList<EqkRupture> eqkRupList, boolean updateCurrRuptures)
+            ArrayList<EqkRupture> eqkRupList)
             throws java.rmi.RemoteException;
 
 }
--- a/src/org/opensha/sha/calc/HazardCurveCalculator.java
+++ b/src/org/opensha/sha/calc/HazardCurveCalculator.java
@@ -18,7 +18,6 @@
 
 package org.opensha.sha.calc;
 
-import java.rmi.RemoteException;
 import java.rmi.server.UnicastRemoteObject;
 import java.util.ArrayList;
 import java.util.ListIterator;
@@ -27,25 +26,19 @@
 import org.opensha.commons.data.Site;
 import org.opensha.commons.data.function.ArbitrarilyDiscretizedFunc;
 import org.opensha.commons.data.function.DiscretizedFuncAPI;
-import org.opensha.commons.geo.Location;
 import org.opensha.commons.param.ArbitrarilyDiscretizedFuncParameter;
 import org.opensha.commons.param.BooleanParameter;
 import org.opensha.commons.param.DoubleParameter;
 import org.opensha.commons.param.IntegerParameter;
-import org.opensha.commons.param.ParameterAPI;
 import org.opensha.commons.param.ParameterList;
 import org.opensha.commons.param.event.ParameterChangeWarningEvent;
 import org.opensha.commons.param.event.ParameterChangeWarningListener;
-import org.opensha.sha.earthquake.EqkRupForecast;
 import org.opensha.sha.earthquake.EqkRupForecastAPI;
 import org.opensha.sha.earthquake.EqkRupture;
 import org.opensha.sha.earthquake.ProbEqkRupture;
 import org.opensha.sha.earthquake.ProbEqkSource;
-// import
-// org.opensha.sha.earthquake.rupForecastImpl.Frankel96.Frankel96_EqkRupForecast;
 import org.opensha.sha.imr.AttenuationRelationship;
 import org.opensha.sha.imr.ScalarIntensityMeasureRelationshipAPI;
-// import org.opensha.sha.imr.attenRelImpl.BJF_1997_AttenRel;
 import org.opensha.sha.util.TRTUtils;
 import org.opensha.sha.util.TectonicRegionType;
 
@@ -113,14 +106,11 @@
             "Number of stochastic event sets for those types of calculations";
     public final int NUM_STOCH_EVENT_SETS_PARAM_MIN = 1;
     public final int NUM_STOCH_EVENT_SETS_PARAM_MAX = Integer.MAX_VALUE;
-    public final static Integer NUM_STOCH_EVENT_SETS_PARAM_DEFAULT =
-            new Integer(1);
+    public final static Integer NUM_STOCH_EVENT_SETS_PARAM_DEFAULT = 1;
 
     private ParameterList adjustableParams;
 
     // misc counting and index variables
-    protected int currRuptures = -1;
-    protected int totRuptures = 0;
     protected int sourceIndex;
     protected int numSources;
 
@@ -315,17 +305,12 @@
                     EqkRupForecastAPI eqkRupForecast)
                     throws java.rmi.RemoteException {
 
-        // System.out.println("Haz Curv Calc: maxDistanceParam.getValue()="+maxDistanceParam.getValue().toString());
-        // System.out.println("Haz Curv Calc: numStochEventSetRealizationsParam.getValue()="+numStochEventSetRealizationsParam.getValue().toString());
-        // System.out.println("Haz Curv Calc: includeMagDistFilterParam.getValue()="+includeMagDistFilterParam.getValue().toString());
         if (includeMagDistFilterParam.getValue())
             System.out.println("Haz Curv Calc: magDistCutoffParam.getValue()="
                     + magDistCutoffParam.getValue().toString());
 
-        this.currRuptures = -1;
-
         /*
-         * this determines how the calucations are done (doing it the way it's
+         * this determines how the calculations are done (doing it the way it's
          * outlined in our original SRL paper gives probs greater than 1 if the
          * total rate of events for the source exceeds 1.0, even if the rates of
          * individual ruptures are << 1).
@@ -337,7 +322,7 @@
         ArbitrarilyDiscretizedFunc sourceHazFunc =
                 (ArbitrarilyDiscretizedFunc) hazFunction.deepClone();
 
-        // declare some varibles used in the calculation
+        // declare some variables used in the calculation
         double qkProb, distance;
         int k;
 
@@ -359,21 +344,6 @@
 
         // get total number of sources
         numSources = eqkRupForecast.getNumSources();
-        // System.out.println("Number of Sources: "+numSources);
-        // System.out.println("ERF info: "+
-        // eqkRupForecast.getClass().getName());
-
-        // compute the total number of ruptures for updating the progress bar
-        totRuptures = 0;
-        sourceIndex = 0;
-        for (sourceIndex = 0; sourceIndex < numSources; ++sourceIndex)
-            totRuptures +=
-                    eqkRupForecast.getSource(sourceIndex).getNumRuptures();
-        // System.out.println("Total number of ruptures:"+ totRuptures);
-
-        // init the current rupture number (also for progress bar)
-        currRuptures = 0;
-        int numRupRejected = 0;
 
         // initialize the hazard function to 1.0
         initDiscretizeValues(hazFunction, 1.0);
@@ -395,8 +365,7 @@
             // set the IMR according to the tectonic region of the source (if
             // there is more than one)
             TectonicRegionType trt = source.getTectonicRegionType();
-            ScalarIntensityMeasureRelationshipAPI imr =
-                    TRTUtils.getIMRForTRT(imrMap, trt);
+            ScalarIntensityMeasureRelationshipAPI imr = imrMap.get(trt);
 
             // compute the source's distance from the site and skip if it's too
             // far away
@@ -404,11 +373,8 @@
 
             // apply distance cutoff to source
             if (distance > maxDistance) {
-                currRuptures += source.getNumRuptures(); // update progress bar
-                                                         // for skipped ruptures
                 continue;
             }
-            // System.out.println(" dist: " + distance);
 
             // get magThreshold if we're to use the mag-dist cutoff filter
             if (includeMagDistFilter) {
@@ -429,7 +395,7 @@
             int numRuptures = source.getNumRuptures();
 
             // loop over these ruptures
-            for (int n = 0; n < numRuptures; n++, ++currRuptures) {
+            for (int n = 0; n < numRuptures; n++) {
 
                 EqkRupture rupture = source.getRupture(n);
 
@@ -438,7 +404,6 @@
 
                 // apply magThreshold if we're to use the mag-dist cutoff filter
                 if (includeMagDistFilter && rupture.getMag() < magThresh) {
-                    numRupRejected += 1;
                     continue;
                 }
 
@@ -504,8 +469,6 @@
             System.out.println(C + "hazFunction.toString"
                     + hazFunction.toString());
 
-        // System.out.println("numRupRejected="+numRupRejected);
-
         return hazFunction;
     }
 
@@ -554,18 +517,10 @@
         hazCurve = hazFunction.deepClone();
         initDiscretizeValues(hazFunction, 0);
         int numPts = hazCurve.getNum();
-        // for progress bar
-        currRuptures = 0;
-        // totRuptures=numEventSets;
 
         for (int i = 0; i < numEventSets; i++) {
             ArrayList<EqkRupture> events = eqkRupForecast.drawRandomEventSet();
-            if (i == 0)
-                totRuptures = events.size() * numEventSets; // this is an
-                                                            // approximate total
-                                                            // number of events
-            currRuptures += events.size();
-            getEventSetHazardCurve(hazCurve, site, imr, events, false);
+            getEventSetHazardCurve(hazCurve, site, imr, events);
             for (int x = 0; x < numPts; x++)
                 hazFunction.set(x, hazFunction.getY(x) + hazCurve.getY(x));
         }
@@ -593,15 +548,12 @@
      *            : selected IMR object
      * @param eqkRupForecast
      *            : selected Earthquake rup forecast
-     * @param updateCurrRuptures
-     *            : tells whether to update current ruptures (for the
-     *            getCurrRuptures() method used for progress bars)
      * @return
      */
     public DiscretizedFuncAPI getEventSetHazardCurve(
             DiscretizedFuncAPI hazFunction, Site site,
             ScalarIntensityMeasureRelationshipAPI imr,
-            ArrayList<EqkRupture> eqkRupList, boolean updateCurrRuptures)
+            ArrayList<EqkRupture> eqkRupList)
             throws java.rmi.RemoteException {
 
         ArbitrarilyDiscretizedFunc condProbFunc =
@@ -614,8 +566,7 @@
         // parameter changes.
         ((AttenuationRelationship) imr).resetParameterEventListeners();
 
-        // declare some varibles used in the calculation
-        double distance;
+        // declare some variables used in the calculation
         int k;
 
         // get the number of points
@@ -623,19 +574,11 @@
 
         // define distance filtering stuff
         double maxDistance = maxDistanceParam.getValue();
-        boolean includeMagDistFilter = includeMagDistFilterParam.getValue();
 
         // set the maximum distance in the attenuation relationship
         imr.setUserMaxDistance(maxDistance);
 
         int totRups = eqkRupList.size();
-        // progress bar stuff
-        if (updateCurrRuptures) {
-            totRuptures = totRups;
-            currRuptures = 0;
-        }
-
-        int numRupRejected = 0;
 
         // initialize the hazard function to 1.0 (initial total non-exceedance
         // probability)
@@ -647,24 +590,11 @@
         if (D)
             System.out.println(C + ": starting hazard curve calculation");
 
-        // System.out.println("totRuptures="+totRuptures);
-
         // loop over ruptures
         for (int n = 0; n < totRups; n++) {
 
-            if (updateCurrRuptures)
-                ++currRuptures;
-
             EqkRupture rupture = eqkRupList.get(n);
 
-            /*
-             * // apply mag-dist cutoff filter if(includeMagDistFilter) {
-             * //distance=??; // NEED TO COMPUTE THIS DISTANCE
-             * if(rupture.getMag() <
-             * magDistCutoffParam.getValue().getInterpolatedY(distance) {
-             * numRupRejected += 1; continue; }
-             */
-
             // set the EqkRup in the IMR
             imr.setEqkRupture(rupture);
 
@@ -681,16 +611,10 @@
 
         }
 
-        // System.out.println(C+"hazFunction.toString"+hazFunction.toString());
-
         // now convert from total non-exceed prob to total exceed prob
         for (int i = 0; i < numPoints; ++i)
             hazFunction.set(i, 1.0 - hazFunction.getY(i));
 
-        // System.out.println(C+"hazFunction.toString"+hazFunction.toString());
-
-        // System.out.println("numRupRejected="+numRupRejected);
-
         return hazFunction;
     }
 
@@ -756,25 +680,6 @@
     }
 
     /**
-     * 
-     * @returns the current rupture being traversed
-     * @throws java.rmi.RemoteException
-     */
-    public int getCurrRuptures() throws java.rmi.RemoteException {
-        return this.currRuptures;
-    }
-
-    /**
-     * 
-     * @returns the total number of ruptures in the earthquake rupture forecast
-     *          model
-     * @throws java.rmi.RemoteException
-     */
-    public int getTotRuptures() throws java.rmi.RemoteException {
-        return this.totRuptures;
-    }
-
-    /**
      * stops the Hazard Curve calculations.
      * 
      * @throws java.rmi.RemoteException
@@ -834,107 +739,8 @@
         return adjustableParams.getParametersIterator();
     }
 
-    // /**
-    // * This tests whether the average over many curves from getEventSetCurve
-    // * equals what is given by getHazardCurve.
-    // */
-    // public void testEventSetHazardCurve(int numIterations) {
-    // // set distance filter large since these are handled slightly differently
-    // in each calc
-    // maxDistanceParam.setValue(300);
-    // // do not apply mag-dist fileter
-    // includeMagDistFilterParam.setValue(false);
-    // numStochEventSetRealizationsParam.setValue(numIterations);
-    //
-    // ScalarIntensityMeasureRelationshipAPI imr = new BJF_1997_AttenRel(this);
-    // imr.setParamDefaults();
-    // imr.setIntensityMeasure("PGA");
-    //
-    // Site site = new Site();
-    // ListIterator it = imr.getSiteParamsIterator();
-    // while(it.hasNext())
-    // site.addParameter((ParameterAPI)it.next());
-    // site.setLocation(new Location(34,-118));
-    //
-    // EqkRupForecast eqkRupForecast = new Frankel96_EqkRupForecast();
-    // eqkRupForecast.updateForecast();
-    //
-    // ArbitrarilyDiscretizedFunc hazCurve = new ArbitrarilyDiscretizedFunc();
-    // hazCurve.set(-3.,1); // log(0.001)
-    // hazCurve.set(-2.,1);
-    // hazCurve.set(-1.,1);
-    // hazCurve.set(1.,1);
-    // hazCurve.set(2.,1); // log(10)
-    //
-    // hazCurve.setName("Hazard Curve");
-    //
-    // try {
-    // this.getHazardCurve(hazCurve, site, imr, eqkRupForecast);
-    // } catch (RemoteException e) {
-    // // TODO Auto-generated catch block
-    // e.printStackTrace();
-    // }
-    //
-    // System.out.println(hazCurve.toString());
-    //
-    // ArbitrarilyDiscretizedFunc aveCurve = hazCurve.deepClone();
-    // try {
-    // getAverageEventSetHazardCurve(aveCurve,site, imr,eqkRupForecast);
-    // } catch (RemoteException e1) {
-    // // TODO Auto-generated catch block
-    // e1.printStackTrace();
-    // }
-    //
-    // /*
-    // this.initDiscretizeValues(aveCurve, 0.0);
-    // ArbitrarilyDiscretizedFunc curve = hazCurve.deepClone();
-    // for(int i=0; i<numIterations;i++) {
-    // try {
-    // getEventSetHazardCurve(curve, site, imr,
-    // eqkRupForecast.drawRandomEventSet());
-    // for(int x=0; x<curve.getNum();x++) aveCurve.set(x,
-    // aveCurve.getY(x)+curve.getY(x));
-    // } catch (RemoteException e) {
-    // // TODO Auto-generated catch block
-    // e.printStackTrace();
-    // }
-    // }
-    // for(int x=0; x<curve.getNum();x++) aveCurve.set(x,
-    // aveCurve.getY(x)/numIterations);
-    // */
-    //
-    // aveCurve.setName("Ave from "+numIterations+" event sets");
-    // System.out.println(aveCurve.toString());
-    //
-    // }
-
     // added this and the associated API implementation to instantiate
     // BJF_1997_AttenRel in the above
     public void parameterChangeWarning(ParameterChangeWarningEvent event) {
     };
-
-    // // this is temporary for testing purposes
-    // public static void main(String[] args) {
-    // HazardCurveCalculator calc;
-    // try {
-    // calc = new HazardCurveCalculator();
-    // calc.testEventSetHazardCurve(1000);
-    // } catch (RemoteException e) {
-    // // TODO Auto-generated catch block
-    // e.printStackTrace();
-    // }
-    //
-    // /*
-    // double temp1, temp2, temp3, temp4;
-    // boolean OK;
-    // for(double n=1; n<2;n += 0.02) {
-    // temp1 = Math.pow(10,n);
-    // temp2 = 1.0-Math.exp(-temp1);
-    // temp3 = Math.log(1.0-temp2);
-    // temp4 = (temp3+temp1)/temp1;
-    // OK = temp1<=30;
-    // System.out.println((float)n+"\t"+temp1+"\t"+temp2+"\t"+temp3+"\t"+temp4+"\t"+OK);
-    // }
-    // */
-    // }
 }
--- a/src/org/opensha/sha/earthquake/rupForecastImpl/PointToLineSource.java
+++ b/src/org/opensha/sha/earthquake/rupForecastImpl/PointToLineSource.java
@@ -19,12 +19,10 @@
 package org.opensha.sha.earthquake.rupForecastImpl;
 
 import java.util.ArrayList;
-import java.util.Iterator;
 
 import org.opensha.commons.calc.magScalingRelations.MagAreaRelationship;
 import org.opensha.commons.calc.magScalingRelations.MagLengthRelationship;
 import org.opensha.commons.calc.magScalingRelations.MagScalingRelationship;
-import org.opensha.commons.data.DataPoint2D;
 import org.opensha.commons.data.Site;
 import org.opensha.commons.data.function.ArbitrarilyDiscretizedFunc;
 import org.opensha.commons.geo.LocationVector;
@@ -65,7 +63,7 @@
         java.io.Serializable {
 
     // for Debug purposes
-    protected static String C = new String("PointToLineEqkSource");
+    protected static String C = "PointToLineEqkSource";
     protected static String NAME = "Point-to-Line Source";
     protected boolean D = false;
 
@@ -186,8 +184,6 @@
         probEqkRuptureList = new ArrayList<ProbEqkRupture>();
         rates = new ArrayList<Double>();
 
-        // System.out.println((float)rupLength+"\t"+(float)mag+"\t"+(float)lowerSeisDepth+"\t"+(float)dip+"\t"+magScalingRel);
-
         if (numStrikes == -1) { // random or applied strike
             for (int i = 0; i < magFreqDists.length; i++) {
                 mkAndAddRuptures(location, magFreqDists[i], focalMechanisms[i],
@@ -292,7 +288,7 @@
                             getRupLength(mag, aveRupTopVersusMag, lowerSeisDepth,
                                     dip, magScalingRel);
 
-                    // get randome strike if needed (between -90 and + 90)
+                    // get random strike if needed (between -90 and + 90)
                     if (isStrikeRandom) {
                         strike = (Math.random() - 0.5) * 180.0;
                     }
@@ -315,8 +311,12 @@
                 }
                 // if it's smaller set point surface at hypocentral depth
                 else{
-                	PointSurface surf = new PointSurface(loc.getLatitude(),loc.getLongitude(),defaultHypoDepth);
-                	rupture.setRuptureSurface(surf);
+                    PointSurface surf = new PointSurface(loc.getLatitude(),
+                                                         loc.getLongitude(),
+                                                         defaultHypoDepth);
+                    surf.setAveStrike(strike);
+                    surf.setAveDip(dip);
+                    rupture.setRuptureSurface(surf);
                 }
 
                 // add the rupture to the list and save the rate in case the
@@ -362,8 +362,6 @@
             throw new RuntimeException("bad type of MagScalingRelationship: "
                     + magScalingRel);
 
-        // System.out.println((float)rupLength+"\t"+(float)mag+"\t"+(float)lowerSeisDepth+"\t"+(float)dip+"\t"+magScalingRel);
-
         return rupLength;
     }
 
--- a/src/org/opensha/sha/faultSurface/PointSurface.java
+++ b/src/org/opensha/sha/faultSurface/PointSurface.java
@@ -70,14 +70,14 @@
     /**
      * The average strike of this surface on the Earth. Even though this is a
      * point source, an average strike can be assigned to it to assist with
-     * particular scientific caculations. Initially set to NaN.
+     * particular scientific calculations. Initially set to NaN.
      */
     protected double aveStrike = Double.NaN;
 
     /**
      * The average dip of this surface into the Earth. Even though this is a
      * point source, an average dip can be assigned to it to assist with
-     * particular scientific caculations. Initially set to NaN.
+     * particular scientific calculations. Initially set to NaN.
      */
     protected double aveDip = Double.NaN;
 
--- a/src/org/opensha/sha/imr/attenRelImpl/Abrahamson_2000_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/Abrahamson_2000_AttenRel.java
@@ -1168,7 +1168,7 @@
 
         protected final static String C =
                 "Abrahamson_2000_AttenRelCoefficients";
-        protected final static boolean D = true;
+        protected final static boolean D = false;
 
         /** For serialization. */
         private static final long serialVersionUID = 1234567890987654321L;
--- a/src/org/opensha/sha/imr/attenRelImpl/AS_1997_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/AS_1997_AttenRel.java
@@ -1353,7 +1353,7 @@
     class AS_1997_AttenRelCoefficients implements NamedObjectAPI {
 
         protected final static String C = "AS_1997_AttenRelCoefficients";
-        protected final static boolean D = true;
+        protected final static boolean D = false;
 
         /** For serialization. */
         private static final long serialVersionUID = 1234567890987654322L;
--- a/src/org/opensha/sha/imr/attenRelImpl/AS_2008_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/AS_2008_AttenRel.java
@@ -63,6 +63,7 @@
 import org.opensha.sha.imr.param.SiteParams.DepthTo1pt0kmPerSecParam;
 import org.opensha.sha.imr.param.SiteParams.Vs30_Param;
 import org.opensha.sha.imr.param.SiteParams.Vs30_TypeParam;
+import org.opensha.sha.imr.param.SiteParams.Vs30_TypeParam.Vs30Type;
 
 /**
  * <b>Title:</b> AS_2008_AttenRel
@@ -1478,7 +1479,7 @@
         } else if (pName.equals(Vs30_Param.NAME)) {
             vs30 = ((Double) val).doubleValue();
         } else if (pName.equals(Vs30_TypeParam.NAME)) {
-            if (((String) val).equals(Vs30_TypeParam.VS30_TYPE_MEASURED)) {
+            if (((String) val).equals(Vs30Type.Measured.toString())) {
                 vsm = 1;
             } else {
                 vsm = 0;
--- a/src/org/opensha/sha/imr/attenRelImpl/Campbell_1997_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/Campbell_1997_AttenRel.java
@@ -1048,7 +1048,7 @@
     class Campbell_1997_AttenRelCoefficients implements NamedObjectAPI {
 
         protected final static String C = "Campbell_1997_AttenRelCoefficients";
-        protected final static boolean D = true;
+        protected final static boolean D = false;
         /** For serialization. */
         private static final long serialVersionUID = 1234567890987654324L;
 
--- a/src/org/opensha/sha/imr/attenRelImpl/CB_2003_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/CB_2003_AttenRel.java
@@ -1175,7 +1175,7 @@
         /** For serialization. */
         private static final long serialVersionUID = 1234567890987654325L;
         protected final static String C = "CB_2003_AttenRelCoefficients";
-        protected final static boolean D = true;
+        protected final static boolean D = false;
 
         protected String name;
         protected double period = -1;
--- a/src/org/opensha/sha/imr/attenRelImpl/CY_2008_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/CY_2008_AttenRel.java
@@ -56,6 +56,7 @@
 import org.opensha.sha.imr.param.SiteParams.DepthTo1pt0kmPerSecParam;
 import org.opensha.sha.imr.param.SiteParams.Vs30_Param;
 import org.opensha.sha.imr.param.SiteParams.Vs30_TypeParam;
+import org.opensha.sha.imr.param.SiteParams.Vs30_TypeParam.Vs30Type;
 
 /**
  * <b>Title:</b> CY_2006_AttenRel
@@ -516,7 +517,7 @@
 		aftershockParam.setValueAsDefault();
 
 		vs30Param.setValueAsDefault();
-		vs30_TypeParam.setValue(Vs30_TypeParam.VS30_TYPE_INFERRED);
+		vs30_TypeParam.setValue(Vs30Type.Inferred.toString());
 		depthTo1pt0kmPerSecParam.setValueAsDefault();
 
 		distanceRupParam.setValueAsDefault();
@@ -992,7 +993,7 @@
 		} else if (pName.equals(Vs30_Param.NAME)) {
 			vs30 = ((Double) val).doubleValue();
 		} else if (pName.equals(Vs30_TypeParam.NAME)) {
-			if (((String) val).equals(Vs30_TypeParam.VS30_TYPE_MEASURED)) {
+			if (((String) val).equals(Vs30Type.Measured.toString())) {
 				f_meas = 1; // Bob Youngs confirmed by email that this is
 							// correct (f_meas=1-f_inf)
 			} else {
--- a/src/org/opensha/sha/imr/attenRelImpl/SadighEtAl_1997_AttenRel.java
+++ b/src/org/opensha/sha/imr/attenRelImpl/SadighEtAl_1997_AttenRel.java
@@ -760,7 +760,7 @@
 		 */
 
 		protected final static String C = "SCEMY_1997_AttenRelCoefficients";
-		protected final static boolean D = true;
+		protected final static boolean D = false;
 		/** For serialization. */
 		private static final long serialVersionUID = 1234567890987654328L;
 
--- a/src/org/opensha/sha/imr/param/PropagationEffectParams/DistanceX_Parameter.java
+++ b/src/org/opensha/sha/imr/param/PropagationEffectParams/DistanceX_Parameter.java
@@ -55,7 +55,7 @@
     /** Class name used in debug strings */
     protected final static String C = "DistanceJBParameter";
     /** If true debug statements are printed out */
-    protected final static boolean D = true;
+    protected final static boolean D = false;
 
     /** Hardcoded name */
     public final static String NAME = "DistanceX";
--- a/src/org/opensha/sha/imr/param/SiteParams/Vs30_TypeParam.java
+++ b/src/org/opensha/sha/imr/param/SiteParams/Vs30_TypeParam.java
@@ -32,8 +32,10 @@
     public final static String NAME = "Vs30 Type";
     public final static String INFO = "Indicates how Vs30 was obtained";
     // Options for constraint:
-    public final static String VS30_TYPE_MEASURED = "Measured";
-    public final static String VS30_TYPE_INFERRED = "Inferred";
+    public static enum Vs30Type {
+        Measured,
+        Inferred,
+    }
 
     /**
      * This provides maximum flexibility in terms of setting the options and the
@@ -53,13 +55,14 @@
     public Vs30_TypeParam() {
         super(NAME);
         StringConstraint options = new StringConstraint();
-        options.addString(VS30_TYPE_MEASURED);
-        options.addString(VS30_TYPE_INFERRED);
+        for (Vs30Type t : Vs30Type.values()) {
+            options.addString(t.toString());
+        }
         options.setNonEditable();
-        setValue(VS30_TYPE_INFERRED); // need to do this so next line succeeds
+        setValue(Vs30Type.Inferred.toString()); // need to do this so next line succeeds
         setConstraint(options);
         setInfo(INFO);
-        setDefaultValue(VS30_TYPE_INFERRED);
+        setDefaultValue(Vs30Type.Inferred.toString());
         setNonEditable();
     }
 }
--- a/src/org/opensha/sha/util/TRTUtils.java
+++ b/src/org/opensha/sha/util/TRTUtils.java
@@ -1,11 +1,7 @@
 package org.opensha.sha.util;
 
 import java.util.HashMap;
-import java.util.Map;
-
-import org.opensha.commons.exceptions.ParameterException;
 import org.opensha.sha.imr.ScalarIntensityMeasureRelationshipAPI;
-import org.opensha.sha.imr.param.OtherParams.TectonicRegionTypeParam;
 
 public class TRTUtils {
 
@@ -25,66 +21,4 @@
         imrMap.put(TectonicRegionType.ACTIVE_SHALLOW, imr);
         return imrMap;
     }
-
-    /**
-     * This will return the IMR for the given Tectonic Region Type. If the map
-     * has only a single mapping, the first (and only) IMR in the map is
-     * returned without checking that the Tectonic Region Types match.
-     * 
-     * @param imrMap
-     * @param trt
-     * @return
-     */
-    @SuppressWarnings("unchecked")
-    public static
-            ScalarIntensityMeasureRelationshipAPI
-            getIMRForTRT(
-                    Map<TectonicRegionType, ScalarIntensityMeasureRelationshipAPI> imrMap,
-                    TectonicRegionType trt) {
-
-        if (trt == null)
-            // TODO maybe figure out another way to handle this?
-            throw new IllegalArgumentException(
-                    "Tectonic Region Type cannot be null!");
-
-        ScalarIntensityMeasureRelationshipAPI imr;
-        if (imrMap.size() > 1) {
-            imr = imrMap.get(trt);
-            // now set the tectonic region in the imr if it supports this type
-            // (because it might support multiple Tectonic Regions), otherwise
-            // do nothing to force it to take the ruptures anyway (and to avoid
-            // an exception)
-            // what if it support two other types, but not this
-            // one?????????????????????
-            if (imr.isTectonicRegionSupported(trt.toString())) {
-                imr.getParameter(TectonicRegionTypeParam.NAME).setValue(
-                        trt.toString());
-            } else { // set to the default value
-                imr.getParameter(TectonicRegionTypeParam.NAME)
-                        .setValueAsDefault();
-            }
-
-        } else { // only one IMR, so force all sources to be used with this one
-                 // and assume the TectonicRegionTypeParam has already been set
-                 // (e.g., in the gui)
-            imr = getFirstIMR(imrMap); // long winded way of getting the single
-                                       // imr
-        }
-        return imr;
-    }
-
-    /**
-     * Simply returns the first IMR in the map by calling
-     * <code>imrMap.values().iterator().next()</code>. This is useful for
-     * returning the only IMR out of a map with a single TRT.
-     * 
-     * @param imrMap
-     * @return
-     */
-    public static
-            ScalarIntensityMeasureRelationshipAPI
-            getFirstIMR(
-                    Map<TectonicRegionType, ScalarIntensityMeasureRelationshipAPI> imrMap) {
-        return imrMap.values().iterator().next();
-    }
 }
